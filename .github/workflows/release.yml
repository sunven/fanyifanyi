name: Release

on:
  push:
    tags:
      - 'v*' # 触发条件：推送 v* tag (例如 v0.2.0)

permissions:
  contents: write

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup git-cliff
        uses: kenji-miyake/setup-git-cliff@v2

      - name: Generate release notes
        run: |
          git-cliff --tag ${{ github.ref_name }} --strip all > release-notes.md

      - name: Create GitHub Release
        run: |
          gh release create ${{ github.ref_name }} \
            --title "Release ${{ github.ref_name }}" \
            --notes-file release-notes.md
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-tauri:
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            target: aarch64-apple-darwin
            arch: aarch64
          # - platform: macos-latest
          #   target: x86_64-apple-darwin
          #   arch: x86_64
          # - platform: ubuntu-22.04
          #   target: x86_64-unknown-linux-gnu
          #   arch: x86_64
          # - platform: windows-latest
          #   target: x86_64-pc-windows-msvc
          #   arch: x86_64

    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 8

      - name: Get pnpm store directory
        id: pnpm-cache
        run: echo "dir=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Cache pnpm
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.dir }}
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri
          key: ${{ matrix.target }}

      # - name: Install dependencies (Ubuntu only)
      #   if: matrix.platform == 'ubuntu-22.04'
      #   run: |
      #     sudo apt-get update
      #     sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install frontend dependencies
        run: pnpm install

      - name: Setup Tauri signing key
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          if [ "$RUNNER_OS" = "Windows" ]; then
            echo "$TAURI_SIGNING_PRIVATE_KEY" > "$RUNNER_TEMP\\tauri-key"
            echo "TAURI_SIGNING_PRIVATE_KEY_PATH=$RUNNER_TEMP\\tauri-key" >> $GITHUB_ENV
          else
            echo "$TAURI_SIGNING_PRIVATE_KEY" > "$RUNNER_TEMP/tauri-key"
            echo "TAURI_SIGNING_PRIVATE_KEY_PATH=$RUNNER_TEMP/tauri-key" >> $GITHUB_ENV
          fi
          echo "TAURI_SIGNING_PRIVATE_KEY_PASSWORD=$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" >> $GITHUB_ENV
        shell: bash

      - name: Build Tauri app
        run: pnpm tauri build --target ${{ matrix.target }}
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      - name: Upload release assets (macOS)
        if: matrix.platform == 'macos-latest'
        run: |
          # DMG installer
          DMG_PATH=$(find src-tauri/target/${{ matrix.target }}/release/bundle/dmg -name "*.dmg" | head -n 1)
          if [ -f "$DMG_PATH" ]; then
            gh release upload ${{ github.ref_name }} "$DMG_PATH" --clobber
          fi

          # App bundle (tarball) for updater
          # Tauri 2.x automatically generates .app.tar.gz and .sig for updater when signing is enabled
          TARBALL=$(find src-tauri/target/${{ matrix.target }}/release/bundle/macos -name "*.app.tar.gz" ! -name "*.sig" | head -n 1)
          
          if [ -f "$TARBALL" ]; then
            echo "Found updater tarball: $TARBALL"
            
            # Copy and rename tarball
            cp "$TARBALL" "fanyifanyi_${{ matrix.arch }}.app.tar.gz"
            gh release upload ${{ github.ref_name }} "fanyifanyi_${{ matrix.arch }}.app.tar.gz" --clobber
            echo "✓ Uploaded tarball"
            
            # Look for signature file (should be next to the tarball)
            SIG_SOURCE="${TARBALL}.sig"
            if [ -f "$SIG_SOURCE" ]; then
              cp "$SIG_SOURCE" "fanyifanyi_${{ matrix.arch }}.app.tar.gz.sig"
              gh release upload ${{ github.ref_name }} "fanyifanyi_${{ matrix.arch }}.app.tar.gz.sig" --clobber
              echo "✓ Uploaded signature file"
            else
              echo "⚠️ Warning: Signature file not found at $SIG_SOURCE"
              echo "Bundle directory contents:"
              ls -lah "$(dirname "$TARBALL")" || true
              echo "All .sig files in target directory:"
              find src-tauri/target/${{ matrix.target }}/release -name "*.sig" || echo "No .sig files found"
            fi
          else
            echo "⚠️ Warning: No updater tarball found, falling back to manual creation"
            # Fallback: create tarball manually from .app bundle
            APP_PATH=$(find src-tauri/target/${{ matrix.target }}/release/bundle/macos -name "*.app" | head -n 1)
            if [ -d "$APP_PATH" ]; then
              tar czf "fanyifanyi_${{ matrix.arch }}.app.tar.gz" -C "$(dirname "$APP_PATH")" "$(basename "$APP_PATH")"
              gh release upload ${{ github.ref_name }} "fanyifanyi_${{ matrix.arch }}.app.tar.gz" --clobber
              echo "✓ Created and uploaded tarball manually"
              echo "⚠️ Note: Manual tarball will not have a signature file"
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # - name: Upload release assets (Linux)
      #   if: matrix.platform == 'ubuntu-22.04'
      #   run: |
      #     # AppImage
      #     APPIMAGE_PATH=$(find src-tauri/target/${{ matrix.target }}/release/bundle/appimage -name "*.AppImage" | grep -v "\.AppImage\." | head -n 1)
      #     if [ -f "$APPIMAGE_PATH" ]; then
      #       gh release upload ${{ github.ref_name }} "$APPIMAGE_PATH" --clobber
      #
      #       # Updater files
      #       SIG_FILE="${APPIMAGE_PATH}.sig"
      #       if [ -f "$SIG_FILE" ]; then
      #         gh release upload ${{ github.ref_name }} "$SIG_FILE" --clobber
      #       fi
      #     fi
      #
      #     # Deb package
      #     DEB_PATH=$(find src-tauri/target/${{ matrix.target }}/release/bundle/deb -name "*.deb" | head -n 1)
      #     if [ -f "$DEB_PATH" ]; then
      #       gh release upload ${{ github.ref_name }} "$DEB_PATH" --clobber
      #     fi
      #   env:
      #     GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # - name: Upload release assets (Windows)
      #   if: matrix.platform == 'windows-latest'
      #   run: |
      #     # MSI installer
      #     $MSI_PATH = Get-ChildItem -Path "src-tauri/target/${{ matrix.target }}/release/bundle/msi" -Filter "*.msi" | Select-Object -First 1 -ExpandProperty FullName
      #     if (Test-Path $MSI_PATH) {
      #       gh release upload ${{ github.ref_name }} $MSI_PATH --clobber
      #
      #       # Updater files
      #       $SIG_FILE = "$MSI_PATH.sig"
      #       if (Test-Path $SIG_FILE) {
      #         gh release upload ${{ github.ref_name }} $SIG_FILE --clobber
      #       }
      #     }
      #
      #     # NSIS installer
      #     $NSIS_PATH = Get-ChildItem -Path "src-tauri/target/${{ matrix.target }}/release/bundle/nsis" -Filter "*.exe" | Select-Object -First 1 -ExpandProperty FullName
      #     if (Test-Path $NSIS_PATH) {
      #       gh release upload ${{ github.ref_name }} $NSIS_PATH --clobber
      #     }
      #   env:
      #     GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   shell: pwsh

  generate-updater-json:
    needs: build-tauri
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup git-cliff
        uses: kenji-miyake/setup-git-cliff@v2

      - name: Extract version from tag
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Download release assets
        run: gh release download ${{ github.ref_name }} --dir ./release-assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate release notes for updater
        run: |
          git-cliff --tag ${{ github.ref_name }} --strip all > release-assets/notes.md

      - name: Generate unified latest.json
        run: |
          cd release-assets

          # Read release notes and escape for JSON
          NOTES=$(cat notes.md | sed 's/"/\\"/g' | tr '\n' '\\n' | sed 's/\\/\\\\/g')

          # Start building the JSON
          cat > latest.json <<EOF
          {
            "version": "${{ steps.version.outputs.VERSION }}",
            "notes": "$NOTES",
            "pub_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "platforms": {
          EOF

          # macOS aarch64
          if [ -f "fanyifanyi_aarch64.app.tar.gz" ]; then
            SIG_CONTENT=""
            if [ -f "fanyifanyi_aarch64.app.tar.gz.sig" ]; then
              SIG_CONTENT=$(cat fanyifanyi_aarch64.app.tar.gz.sig)
            fi

            cat >> latest.json <<EOF
              "darwin-aarch64": {
                "signature": "$SIG_CONTENT",
                "url": "https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/fanyifanyi_aarch64.app.tar.gz"
              },
          EOF
          fi

          # Close the JSON (remove trailing comma)
          sed -i '$ s/,$//' latest.json
          echo "  }" >> latest.json
          echo "}" >> latest.json

          # Upload latest.json to both current release and latest release
          gh release upload ${{ github.ref_name }} latest.json --clobber
          gh release upload latest latest.json --clobber || true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
